// some fn defn's
:nor ..  -> ?f|f              // the (forgotten) universal
:id .    -> ?t ?t            // alias for dup
:not .   -> id nor ?t        // not from nor and id
:and ..  -> ?t|t             // simple enough
:nand .. -> and not ?t
:or ..   -> nor not ?t
:xor ..  -> or . .. nand and ?t
:xnor .. -> xor not ?t

t       //<- push a t
f       //<- push an f
nand    //<- push the value of nand on the stack
?t      //<- if the peek of the stack is t, push t, else push f
?f|t    //<- test if peek and peek[-1] both are f, if so, push t
!t      //<- assert the top of the stack is true -- exit irrecoverably otherwise


//operators:
:somename ... -> fn defn
//?  //test+push
//!  //assert

//comments:
// double slashes to end of line

//values:
t //- true
f //- false

//that's it

//semantics - macro and test calls pop the appropriate values from the 
//            main stack, push them to a temporary stack, and execute
//            their body on them.  in all cases, ? tests the current stack
//            and pushes to the calling stack, thus the final ? t for most 
//            of the functions -- it's the only way to touch the calling 
//            stack after the call.
