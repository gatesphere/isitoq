// some fn defn's
:nand .. -> ?f|f            // the universal
:id .    -> ?. ?.          // alias for dup
:not .   -> id nand ? t |       // not from nand and id
:and ..  -> nand not ? t |
:or ..   ->  id nand swap id nand nand ? t |
:nor ..  -> or not ? t |
:xor ..  -> or . .. nand and ? t |
:xnor .. -> xor not ? t |

t       //<- push a t
f       //<- push an f
nand    //<- push the value of nand on the stack
?t      //<- pop stack, if the pop of the stack is t, push t, else push f
?f|f    //<- pop stack twice, test if both are f, if so, push t
!t      //<- assert the top of the stack is true -- exit irrecoverably otherwise


//operators:
:somename ... -> fn defn
?  //pop+test+push
!  //assert

//comments:
// double slashes to end of line

//values:
t //- true
f //- false

//that's it

//semantics - macro and test calls pop the appropriate values from the 
//            main stack, push them to a temporary stack, and execute
//            their body on them.  in all cases, ? tests the current stack
//            and pushes to the calling stack, thus the final ? t for most 
//            of the functions -- it's the only way to touch the calling 
//            stack after the call.
